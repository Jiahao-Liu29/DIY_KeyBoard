C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\kali\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main.ls
                    -t) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "./Public/CH554.H"                                                      
   2          #include "./Public/DEBUG.H"
   3          #include <string.h>
   4          #include <stdio.h>
   5          #include "ds2812b.h"
   6          
   7          
   8          
   9          #define THIS_ENDP0_SIZE         DEFAULT_ENDP0_SIZE
  10          #define CapsLockLED 0x02
  11          
  12          UINT8X  Ep0Buffer[8>(THIS_ENDP0_SIZE+2)?8:(THIS_ENDP0_SIZE+2)] _at_ 0x0000;    //¶Ëµã0 OUT&IN»º³åÇø£¬±ØÐëÊ
             -ÇÅ¼µØÖ·
  13          UINT8X  Ep1Buffer[64>(MAX_PACKET_SIZE+2)?64:(MAX_PACKET_SIZE+2)] _at_ 0x000a;  //¶Ëµã1 IN»º³åÇø,±ØÐëÊÇÅ¼µØ
             -Ö·
  14          UINT8X  Ep2Buffer[64<(MAX_PACKET_SIZE+2)?64:(MAX_PACKET_SIZE+2)] _at_ 0x0050;  //¶Ëµã2 IN»º³åÇø,±ØÐëÊÇÅ¼µØ
             -Ö·
  15          UINT8   SetupReq,SetupLen,Ready,Count,FLAG,UsbConfig,LED_VALID;
  16          PUINT8  pDescr;   //USBÅäÖÃ±êÖ¾
  17          USB_SETUP_REQ   SetupReqBuf;  //ÔÝ´æSetup°ü
  18          bit Ep2InKey;
  19          #define UsbSetupBuf     ((PUSB_SETUP_REQ)Ep0Buffer)
  20          #define DEBUG 0
  21          #pragma  NOAREGS
  22           //¶¨ÒåµÄ4¸ö°´¼üÒÔ¼°EC16µÄA¡¢B½Å
  23          sbit LED1 = P3^4;
  24          sbit LED2 = P1^5;
  25          sbit LED3 = P1^4;
  26          sbit LED4 = P1^1;
  27          sbit LED5 = P1^7;
  28          sbit LED6 = P3^1;
  29          sbit LED7 = P3^2;
  30          sbit LED8 = P3^3;
  31          sbit LED17 = P1^6;
  32          
  33          UINT8 key;
  34          
  35          UINT8 EC16_A_State = 0;
  36          UINT8 EC16_A_PState = 0;
  37          UINT8 T0RH = 0; //T0¸ß8Î»ÖØÔØÖµ
  38          UINT8 T0RL = 0; //T0µÍ8Î»ÖØÔØÖµ
  39          //UINT8 KeyState[6] = {1,1,1,1,1,1}; //°´¼ü×´Ì¬
  40          //UINT8 BackState[6] = {1,1,1,1,1,1}; //°´¼üÉÏÒ»´ÎµÄ×´Ì¬
  41          UINT8 KeyState = 1; //°´¼ü×´Ì¬
  42          UINT8 BackState = 1; //°´¼üÉÏÒ»´ÎµÄ×´Ì¬
  43          //unsigned long pdata TimeThr[4] = {1000, 1000, 1000, 1000};
  44          //unsigned long pdata KeyDownTime[4]= {0, 0, 0, 0};
  45          unsigned long pdata TimeThr = 1000;
  46          unsigned long pdata KeyDownTime = 0;
  47          UINT8C key_code_map[6] = {
  48                  0xE7,0x32,0x33,0x34,0x35,0x36         //°´¼ü1,°´¼ü2,°´¼ü3,°´¼ü4,°´¼ü3,°´¼ü4
  49          };
  50          
  51          // P8 ¶Ë¿ÚÐ´Êý¾Ý
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 2   

  52          void write_data(UINT8 dat)
  53          {
  54   1              LED1 = dat & 0x01;
  55   1              LED2 = (dat >> 1) & 0x01;
  56   1              LED3 = (dat >> 2) & 0x01;
  57   1              LED4 = (dat >> 3) & 0x01;
  58   1              LED5 = (dat >> 4) & 0x01;
  59   1              LED6 = (dat >> 5) & 0x01;
  60   1              LED7 = (dat >> 6) & 0x01;
  61   1              LED8 = (dat >> 7) & 0x01;
  62   1      }
  63          
  64          // P8 ¶Ë¿Ú¶ÁÊý¾Ý
  65          UINT8 read_data()
  66          {
  67   1              UINT8 dat = 0x00;
  68   1              dat|=LED8;
  69   1              dat=(dat<<1)|LED7;
  70   1              dat=(dat<<1)|LED6;
  71   1              dat=(dat<<1)|LED5;
  72   1              dat=(dat<<1)|LED4;
  73   1              dat=(dat<<1)|LED3;
  74   1              dat=(dat<<1)|LED2;
  75   1              dat=(dat<<1)|LED1;
  76   1              
  77   1              return dat;
  78   1      }
  79          
  80          
  81          /*ÆÕÍ¨¼üÅÌÊý¾Ý*/
  82          UINT8 HIDKey[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  83          /*¶àÃ½Ìå°´¼üÊý¾Ý*/
  84          UINT8 HIDKeyMUL[4] = {0x00,0x00,0x00,0x00};
  85          
  86          /****×Ö·û´®ÃèÊö·û****/
  87          /*HIDÀà±¨±íÃèÊö·û*/
  88          UINT8C KeyRepDesc[62] =
  89          {
  90          /******************************************************************
  91          ¼üÅÌ·¢ËÍ¸øPCµÄÊý¾ÝÃ¿´Î8¸ö×Ö½Ú£ºBYTE1 BYTE2 BYTE3 BYTE4 BYTE5 BYTE6 BYTE7 BYTE8¡£¶¨Òå·Ö±ðÊÇ£º
  92          BYTE1 --
  93                 |--bit0:   Left Control 
  94                 |--bit1:   Left Shift 
  95                 |--bit2:   Left Alt 
  96                 |--bit3:   Left GUI 
  97                 |--bit4:   Right Control  
  98                 |--bit5:   Right Shift 
  99                 |--bit6:   Right Alt 
 100                 |--bit7:   Right GUI 
 101          BYTE2 -- ÔÝ²»Çå³þ£¬ÓÐµÄµØ·½ËµÊÇ±£ÁôÎ»
 102          BYTE3--BYTE8 -- ÕâÁù¸öÎªÆÕÍ¨°´¼ü
 103          *******************************************************************/
 104              0x05,0x01,0x09,0x06,0xA1,0x01,0x05,0x07,
 105              0x19,0xe0,0x29,0xe7,0x15,0x00,0x25,0x01,
 106              0x75,0x01,0x95,0x08,0x81,0x02,0x95,0x01,
 107              0x75,0x08,0x81,0x01,0x95,0x03,0x75,0x01,
 108              0x05,0x08,0x19,0x01,0x29,0x03,0x91,0x02,
 109              0x95,0x05,0x75,0x01,0x91,0x01,0x95,0x06,
 110              0x75,0x08,0x26,0xff,0x00,0x05,0x07,0x19,
 111              0x00,0x29,0x91,0x81,0x00,0xC0
 112          };
 113          /*¶àÃ½Ìå¼üÅÌ±¨±íÃèÊö·û*/
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 3   

 114          UINT8C KeyMULRepDesc[105] =     
 115          {
 116          /**********************************************************************************************
 117          ¼üÅÌ·¢ËÍ¸øPCµÄÊý¾ÝÃ¿´Î4¸ö×Ö½Ú£ºBYTE1 BYTE2 BYTE3 BYTE4
 118          BYTE1 BYTE2 BYTE3 Õâ3¸ö×Ö½Ú·Ö³É24Î»£¬Ã¿¸öÎ»´ú±íÒ»¸ö°´¼ü£¬1´ú±í°´ÏÂ£¬0Ì§Æð¡£
 119          BYTE1 --
 120                 |--bit0:  Vol-  
 121                 |--bit1:  Vol+ 
 122                 |--bit2:  Mute  
 123                 |--bit3:  Email 
 124                 |--bit4:  Media   
 125                 |--bit5:  WWW Home 
 126                 |--bit6:  Play/Pause 
 127                 |--bit7:  Scan Pre Track 
 128          BYTE2 BYTE3°´ÏÂÃæµÄË³ÐòÅÅÏÂÈ¥£¬BYTE3 bit7£º×îºóÒ»¸öUsage( NULL )¡£
 129          BYTE4 --
 130              ÏµÍ³¹¦ÄÜ°´¼ü£¬¹Ø»ú(0x81)£¬ÐÝÃß(0x82£©£¬»½ÐÑ£¨0x83£©
 131          ***********************************************************************************************/
 132                  0x05, 0x0C, //USAGE_PAGE ÓÃÍ¾Ò³Ñ¡Ôñ0x0c(ÓÃ»§Ò³)
 133                  0x09, 0x01, //USAGE ½ÓÏÂÀ´µÄÓ¦ÓÃ¼¯ºÏÓÃÓÚÓÃ»§¿ØÖÆ
 134                  0xA1, 0x01, //COLLECTION ¿ª¼¯ºÏ
 135                          0x15, 0x00, //LOGICAL_MINIMUM (0)
 136                          0x25, 0x01, //LOGICAL_MAXIMUM (1)
 137                          0x0A, 0xEA, 0x00,               /* Usage( Vol- ) */
 138                          0x0A, 0xE9, 0x00,               /* Usage( Vol+ ) */
 139                          0x0A, 0xE2, 0x00,               /* Usage( Mute ) */
 140                          0x0A, 0x8A, 0x01,               /* Usage( Email ) */
 141                          0x0A, 0x83, 0x01,               /* Usage( Media ) */
 142                          0x0A, 0x23, 0x02,               /* Usage( WWW Home ) */
 143                          0x0A, 0xCD, 0x00,               /* Usage( Play/Pause ) */
 144                          0x0A, 0xB6, 0x00,               /* Usage( Scan Pre Track ) */
 145                          0x0A, 0xB5, 0x00,               /* Usage( Scan Next Track ) */
 146                          0x0A, 0xB7, 0x00,               /* Usage( Stop ) */
 147                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 148                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 149                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 150                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 151                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 152                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 153                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 154                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 155                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 156                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 157                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 158                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 159                          0x0A, 0x00, 0x00,               /* Usage( NULL ) */
 160                          0x0A, 0x11, 0x22,               /* Usage( NULL ) */
 161                          0x75, 0x01, //REPORT_SIZE (1)
 162                          0x95, 0x18, //REPORT_COUNT (24)
 163                          0x81, 0x02, //INPUT (Data,Var,Abs)ÊäÈë24bitÊý¾Ý
 164                          0x05, 0x01, //USAGE_PAGE ÓÃÍ¾Ò³0x01(ÆÕÍ¨×ÀÃæ)
 165                                  0x19, 0x00, //USAGE_MINIMUM ÓÃÍ¾×îÐ¡Öµ0x00(Î´¶¨Òå)
 166                                  0x29, 0x83, //USAGE_MAXIMUM ÓÃÍ¾×î´óÖµ0x83(ÏµÍ³»½ÐÑ)
 167                                  0x15, 0x00, //LOGICAL_MINIMUM (0)
 168                                  0x25, 0x83, //LOGICAL_MAXIMUM (83)
 169                                  0x75, 0x08, //REPORT_SIZE (8)
 170                                  0x95, 0x01, //REPORT_COUNT (1)
 171                                  0x81, 0x00, //INPUT (Data,Ary,Abs)ÊäÈë1×Ö½ÚÊý¾Ý
 172                  0xC0//END_COLLECTION ±ÕºÏ¼¯ºÏ
 173          };
 174          /*Éè±¸ÃèÊö·û*/
 175          UINT8C DevDesc[18] = {
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 4   

 176             0x12,      //bLength×Ö¶Î¡£Éè±¸ÃèÊö·ûµÄ³¤¶ÈÎª18(0x12)×Ö½Ú
 177             0x01,          //bDescriptorType×Ö¶Î¡£Éè±¸ÃèÊö·ûµÄ±àºÅÎª0x01
 178             0x10,0x01, //bcdUSB×Ö¶Î¡£ÕâÀïÉèÖÃ°æ±¾ÎªUSB1.1£¬¼´0x0110¡£
 179                        //ÓÉÓÚÊÇÐ¡¶Ë½á¹¹£¬ËùÒÔµÍ×Ö½ÚÔÚÏÈ£¬¼´0x10£¬0x01¡£
 180             0x00,          //bDeviceClass×Ö¶Î¡£ÎÒÃÇ²»ÔÚÉè±¸ÃèÊö·ûÖÐ¶¨ÒåÉè±¸Àà£¬
 181                        //¶øÔÚ½Ó¿ÚÃèÊö·ûÖÐ¶¨ÒåÉè±¸Àà£¬ËùÒÔ¸Ã×Ö¶ÎµÄÖµÎª0¡£
 182             0x00,          //bDeviceSubClass×Ö¶Î¡£bDeviceClass×Ö¶ÎÎª0Ê±£¬¸Ã×Ö¶ÎÒ²Îª0¡£
 183             0x00,          //bDeviceProtocol×Ö¶Î¡£bDeviceClass×Ö¶ÎÎª0Ê±£¬¸Ã×Ö¶ÎÒ²Îª0¡£
 184             0x08,          //bMaxPacketSize0×Ö¶Î¡£ µÄ¶Ëµã0´óÐ¡µÄ8×Ö½Ú¡£
 185             0x3d,0x41, //idVender×Ö¶Î,×¢ÒâÐ¡¶ËÄ£Ê½£¬µÍ×Ö½ÚÔÚÏÈ¡£
 186             0x3a,0x55, //idProduct×Ö¶Î ²úÆ·IDºÅ¡£×¢ÒâÐ¡¶ËÄ£Ê½£¬µÍ×Ö½ÚÓ¦¸ÃÔÚÇ°¡£
 187             0x00,0x00, //bcdDevice×Ö¶Î¡£×¢ÒâÐ¡¶ËÄ£Ê½£¬µÍ×Ö½ÚÓ¦¸ÃÔÚÇ°¡£
 188             0x00,          //iManufacturer×Ö¶Î¡£³§ÉÌ×Ö·û´®µÄË÷Òý
 189             0x00,          //iProduct×Ö¶Î¡£²úÆ·×Ö·û´®µÄË÷ÒýÖµ,×¢Òâ×Ö·û´®Ë÷ÒýÖµ²»ÒªÊ¹ÓÃÏàÍ¬µÄÖµ¡£
 190             0x00,          //iSerialNumber×Ö¶Î¡£Éè±¸µÄÐòÁÐºÅ×Ö·û´®Ë÷ÒýÖµ¡£
 191             0x01           //bNumConfigurations×Ö¶Î¡£¸ÃÉè±¸Ëù¾ßÓÐµÄÅäÖÃÊý¡£
 192          };
 193          /*ÅäÖÃÃèÊö·û*/
 194          UINT8C CfgDesc[59] =
 195          {
 196           /*ÅäÖÃÃèÊö·û*/
 197              0x09, //bLength×Ö¶Î¡£ÅäÖÃÃèÊö·ûµÄ³¤¶ÈÎª9×Ö½Ú
 198                  0x02, //bDescriptorType×Ö¶Î¡£ÅäÖÃÃèÊö·û±àºÅÎª0x02
 199                  0x3b, //wTotalLength×Ö¶Î¡£ÅäÖÃÃèÊö·û¼¯ºÏµÄ×Ü³¤¶È0x003b£¬°üÀ¨ÅäÖÃÃèÊö·û±¾Éí¡¢½Ó¿ÚÃèÊö·û¡¢ÀàÃèÊö·û¡¢¶ËµãÃèÊ
             -ö·ûµÈ£¬LSB
 200                  0x00, 
 201                  0x02, //bNumInterfaces×Ö¶Î¡£¸ÃÅäÖÃ°üº¬µÄ½Ó¿ÚÊý£¬Ö»ÓÐ2¸ö½Ó¿Ú
 202                  0x01, //bConfiguration×Ö¶Î¡£¸ÃÅäÖÃµÄÖµÎª1
 203                  0x01, //iConfigurationz×Ö¶Î£¬¸ÃÅäÖÃµÄ×Ö·û´®Ë÷Òý¡£
 204                  0xA0, //bmAttributes×Ö¶Î,bit4-bit7ÃèÊöÉè±¸µÄÌØÐÔ
 205                  0x64, //bMaxPower×Ö¶Î£¬¸ÃÉè±¸ÐèÒªµÄ×î´óµçÁ÷Á¿¡£Ã¿µ¥Î»µçÁ÷Îª 2 mA    
 206           /*½Ó¿ÚÃèÊö·û*/
 207              //½Ó¿Ú1£¬ÆÕÍ¨¼üÅÌ
 208              0x09,0x04,0x00,0x00,0x01,0x03,0x01,0x01,0x00, //½Ó¿ÚÃèÊö·û,¼üÅÌ  HIDÉè±¸µÄ¶¨Òå·ÅÖÃÔÚ½Ó¿ÚÃèÊö·ûÖÐ
 209              0x09,0x21,0x11,0x01,0x00,0x01,0x22,0x3e,0x00, //HIDÀàÃèÊö·û
 210              0x07,0x05,0x81,0x03,0x08,0x00,0x0a, //¶ËµãÃèÊö·û
 211                  //½Ó¿Ú2£¬¶àÃ½Ìå°´¼ü
 212                  0x09,0x04,0x01,0x00,0x01,0x03,0x00,0x00,0x00, // ½Ó¿ÚÃèÊö·û
 213                  0x09,0x21,0x00,0x01,0x00,0x01,0x22,0x69,0x00, // HIDÀàÃèÊö·û
 214                  0x07,0x05,0x82,0x03,0x04,0x00,0x0a,     // ¶ËµãÃèÊö·û 
 215          };
 216          /*******************************************************************************
 217          * Function Name  : USBDeviceInit()
 218          * Description    : USBÉè±¸Ä£Ê½ÅäÖÃ,Éè±¸Ä£Ê½Æô¶¯£¬ÊÕ·¢¶ËµãÅäÖÃ£¬ÖÐ¶Ï¿ªÆô
 219          * Input          : None
 220          * Output         : None
 221          * Return         : None
 222          *******************************************************************************/
 223          void USBDeviceInit()
 224          {
 225   1                IE_USB = 0;
 226   1                USB_CTRL = 0x00; //ÏÈÉè¶¨USBÉè±¸Ä£Ê½
 227   1          UEP0_DMA = Ep0Buffer; //¶Ëµã0Êý¾Ý´«ÊäµØÖ·
 228   1          UEP1_DMA = Ep1Buffer; //¶Ëµã1Êý¾Ý´«ÊäµØÖ·
 229   1              UEP2_DMA = Ep2Buffer; //¶Ëµã2Êý¾Ý´«ÊäµØÖ·
 230   1          UEP4_1_MOD = ~(bUEP4_RX_EN | bUEP4_TX_EN |bUEP1_RX_EN | bUEP1_BUF_MOD) | bUEP4_TX_EN;//¶Ëµã1µ¥64×Ö½ÚÊÕ
             -·¢»º³åÇø,¶Ëµã0ÊÕ·¢
 231   1              UEP2_3_MOD = UEP2_3_MOD & ~bUEP2_BUF_MOD | bUEP2_TX_EN;
 232   1          UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK; //OUTÊÂÎñ·µ»ØACK£¬INÊÂÎñ·µ»ØNAK
 233   1          UEP1_CTRL = bUEP_T_TOG | UEP_T_RES_NAK;     //¶Ëµã1ÊÖ¶¯·­×ªÍ¬²½±êÖ¾Î»£¬INÊÂÎñ·µ»ØNAK
 234   1              UEP2_CTRL = bUEP_AUTO_TOG | UEP_T_RES_NAK; //¶Ëµã2×Ô¶¯·­×ªÍ¬²½±êÖ¾Î»£¬INÊÂÎñ·µ»ØNAK
 235   1                      
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 5   

 236   1                USB_DEV_AD = 0x00;
 237   1                UDEV_CTRL = bUD_PD_DIS; // ½ûÖ¹DP/DMÏÂÀ­µç×è
 238   1                USB_CTRL = bUC_DEV_PU_EN | bUC_INT_BUSY | bUC_DMA_EN; // Æô¶¯USBÉè±¸¼°DMA£¬ÔÚÖÐ¶ÏÆÚ¼äÖÐ¶Ï±êÖ¾Î´Çå³ýÇ°×Ô
             -¶¯·µ»ØNAK
 239   1                UDEV_CTRL |= bUD_PORT_EN; // ÔÊÐíUSB¶Ë¿Ú
 240   1                USB_INT_FG = 0xFF; // ÇåÖÐ¶Ï±êÖ¾
 241   1                USB_INT_EN = bUIE_SUSPEND | bUIE_TRANSFER | bUIE_BUS_RST;
 242   1                IE_USB = 1;
 243   1      }
 244          /*******************************************************************************
 245          * Function Name  : Enp1IntIn()
 246          * Description    : USBÉè±¸Ä£Ê½¶Ëµã1µÄÖÐ¶ÏÉÏ´«
 247          * Input          : None
 248          * Output         : None
 249          * Return         : None
 250          *******************************************************************************/
 251          void Enp1IntIn( )
 252          {
 253   1          memcpy( Ep1Buffer, HIDKey, sizeof(HIDKey)); //¼ÓÔØÉÏ´«Êý¾Ý
 254   1          UEP1_T_LEN = sizeof(HIDKey); //ÉÏ´«Êý¾Ý³¤¶È
 255   1          UEP1_CTRL = UEP1_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK; //ÓÐÊý¾ÝÊ±ÉÏ´«Êý¾Ý²¢Ó¦´ðACK
 256   1      }
 257          /*******************************************************************************
 258          * Function Name  : Enp2IntIn()
 259          * Description    : USBÉè±¸Ä£Ê½¶Ëµã2µÄÖÐ¶ÏÉÏ´«
 260          * Input          : None
 261          * Output         : None
 262          * Return         : None
 263          *******************************************************************************/
 264          void Enp2IntIn( )
 265          {
 266   1          memcpy( Ep2Buffer, HIDKeyMUL, sizeof(HIDKeyMUL)); //¼ÓÔØÉÏ´«Êý¾Ý
 267   1          UEP2_T_LEN = sizeof(HIDKeyMUL); //ÉÏ´«Êý¾Ý³¤¶È
 268   1          UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_ACK; //ÓÐÊý¾ÝÊ±ÉÏ´«Êý¾Ý²¢Ó¦´ðACK
 269   1      }
 270          
 271          /*******************************************************************************
 272          * Function Name  : DeviceInterrupt()
 273          * Description    : CH559USBÖÐ¶Ï´¦Àíº¯Êý
 274          *******************************************************************************/
 275          void    DeviceInterrupt( void ) interrupt INT_NO_USB using 1                      //USBÖÐ¶Ï·þÎñ³ÌÐò,Ê¹ÓÃ¼Ä
             -´æÆ÷×é1
 276          {
 277   1          UINT8 len;
 278   1          if(UIF_TRANSFER)                                                            //USB´«ÊäÍê³É±êÖ¾
 279   1          {
 280   2              switch (USB_INT_ST & (MASK_UIS_TOKEN | MASK_UIS_ENDP))
 281   2              {
 282   3              case UIS_TOKEN_IN | 2:                                                  //endpoint 2# ÖÐ¶Ï¶ËµãÉÏ´«
 283   3                  UEP2_T_LEN = 0;                                                     //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 284   3      //            UEP1_CTRL ^= bUEP_T_TOG;                                          //Èç¹û²»ÉèÖÃ×Ô¶¯·­×ªÔòÐèÒª
             -ÊÖ¶¯·­×ª
 285   3                  UEP2_CTRL = UEP2_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //Ä¬ÈÏÓ¦´ðNAK
 286   3                              FLAG = 1;                                                                                                                       /*´«ÊäÍê³É±êÖ¾*/
 287   3                  break;
 288   3              case UIS_TOKEN_IN | 1:                                                  //endpoint 1# ÖÐ¶Ï¶ËµãÉÏ´«
 289   3                  UEP1_T_LEN = 0;                                                     //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 290   3      //            UEP2_CTRL ^= bUEP_T_TOG;                                          //Èç¹û²»ÉèÖÃ×Ô¶¯·­×ªÔòÐèÒª
             -ÊÖ¶¯·­×ª
 291   3                  UEP1_CTRL = UEP1_CTRL & ~ MASK_UEP_T_RES | UEP_T_RES_NAK;           //Ä¬ÈÏÓ¦´ðNAK
 292   3                  FLAG = 1;                                                           /*´«ÊäÍê³É±êÖ¾*/
 293   3                  break;
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 6   

 294   3              case UIS_TOKEN_SETUP | 0:                                                //SETUPÊÂÎñ
 295   3                  len = USB_RX_LEN;
 296   3                  if(len == (sizeof(USB_SETUP_REQ)))
 297   3                  {
 298   4                      SetupLen = UsbSetupBuf->wLengthL;
 299   4                      if(UsbSetupBuf->wLengthH || SetupLen > 0x7F )
 300   4                      {
 301   5                          SetupLen = 0x7F;    // ÏÞÖÆ×Ü³¤¶È
 302   5                      }
 303   4                      len = 0;                                                        // Ä¬ÈÏÎª³É¹¦²¢ÇÒÉÏ´«0³¤¶È
 304   4                      SetupReq = UsbSetupBuf->bRequest;                                                               
 305   4                      if ( ( UsbSetupBuf->bRequestType & USB_REQ_TYP_MASK ) != USB_REQ_TYP_STANDARD )/* HIDÀàÃüÁ
             -î */
 306   4                      {
 307   5                                                                              switch( SetupReq ) 
 308   5                                                                              {
 309   6                                                                                      case 0x01://GetReport
 310   6                                                                                                       break;
 311   6                                                                                      case 0x02://GetIdle
 312   6                                                                                                       break; 
 313   6                                                                                      case 0x03://GetProtocol
 314   6                                                                                                       break;                         
 315   6                                                                                      case 0x09://SetReport                                                                           
 316   6                                                                                                       break;
 317   6                                                                                      case 0x0A://SetIdle
 318   6                                                                                                       break; 
 319   6                                                                                      case 0x0B://SetProtocol
 320   6                                                                                                       break;
 321   6                                                                                      default:
 322   6                                                                                                       len = 0xFF;                                                                                                                /*ÃüÁî²»Ö§³Ö*/                                      
 323   6                                                                                                       break;
 324   6                                                                        }     
 325   5                      }
 326   4                      else
 327   4                      {//±ê×¼ÇëÇó
 328   5                          switch(SetupReq)                                        //ÇëÇóÂë
 329   5                          {
 330   6                          case USB_GET_DESCRIPTOR:
 331   6                              switch(UsbSetupBuf->wValueH)
 332   6                              {
 333   7                              case 1:                                             //Éè±¸ÃèÊö·û
 334   7                                  pDescr = DevDesc;                               //°ÑÉè±¸ÃèÊö·ûËÍµ½Òª·¢ËÍµÄ»º³å
             -Çø
 335   7                                  len = sizeof(DevDesc);
 336   7                                  break;
 337   7                              case 2:                                             //ÅäÖÃÃèÊö·û
 338   7                                  pDescr = CfgDesc;                               //°ÑÉè±¸ÃèÊö·ûËÍµ½Òª·¢ËÍµÄ»º³å
             -Çø
 339   7                                  len = sizeof(CfgDesc);
 340   7                                  break;
 341   7                              case 0x22:                                          //±¨±íÃèÊö·û
 342   7                                  if(UsbSetupBuf->wIndexL == 0)                   //½Ó¿Ú0±¨±íÃèÊö·û
 343   7                                  {
 344   8                                      pDescr = KeyRepDesc;                        //Êý¾Ý×¼±¸ÉÏ´«
 345   8                                      len = sizeof(KeyRepDesc);                                                               
 346   8                                  }
 347   7                                                              if(UsbSetupBuf->wIndexL == 1)                   //½Ó¿Ú0±¨±íÃèÊö·û
 348   7                                  {
 349   8                                      pDescr = KeyMULRepDesc;                        //Êý¾Ý×¼±¸ÉÏ´«
 350   8                                      len = sizeof(KeyMULRepDesc);
 351   8                                      Ready = 1;                                  //Èç¹ûÓÐ¸ü¶à½Ó¿Ú£¬¸Ã±ê×¼Î»Ó¦¸Ã
             -ÔÚ×îºóÒ»¸ö½Ó¿ÚÅäÖÃÍê³ÉºóÓÐÐ§
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 7   

 352   8                                      //IE_UART1 = 1;//¿ªÆô´®¿ÚÖÐ¶Ï                                                                                                                   
 353   8                                                                                                                              
 354   8                                  }
 355   7                                  else
 356   7                                  {
 357   8                                      len = 0xff;                                 //±¾³ÌÐòÖ»ÓÐ2¸ö½Ó¿Ú£¬Õâ¾ä»°Õý³
             -£²»¿ÉÄÜÖ´ÐÐ
 358   8                                  }
 359   7                                  break;
 360   7                              default:
 361   7                                  len = 0xff;                                     //²»Ö§³ÖµÄÃüÁî»òÕß³ö´í
 362   7                                  break;
 363   7                              }
 364   6                              if ( SetupLen > len )
 365   6                              {
 366   7                                  SetupLen = len;    //ÏÞÖÆ×Ü³¤¶È
 367   7                              }
 368   6                              len = SetupLen >= 8 ? 8 : SetupLen;                  //±¾´Î´«Êä³¤¶È
 369   6                              memcpy(Ep0Buffer,pDescr,len);                        //¼ÓÔØÉÏ´«Êý¾Ý
 370   6                              SetupLen -= len;
 371   6                              pDescr += len;
 372   6                              break;
 373   6                          case USB_SET_ADDRESS:
 374   6                              SetupLen = UsbSetupBuf->wValueL;                     //ÔÝ´æUSBÉè±¸µØÖ·
 375   6                              break;
 376   6                          case USB_GET_CONFIGURATION:
 377   6                              Ep0Buffer[0] = UsbConfig;
 378   6                              if ( SetupLen >= 1 )
 379   6                              {
 380   7                                  len = 1;
 381   7                              }
 382   6                              break;
 383   6                          case USB_SET_CONFIGURATION:
 384   6                              UsbConfig = UsbSetupBuf->wValueL;
 385   6                              break;
 386   6                          case 0x0A:
 387   6                              break;
 388   6                          case USB_CLEAR_FEATURE:                                            //Clear Feature
 389   6                              if ( ( UsbSetupBuf->bRequestType & USB_REQ_RECIP_MASK ) == USB_REQ_RECIP_ENDP )// 
             -¶Ëµã
 390   6                              {
 391   7                                  switch( UsbSetupBuf->wIndexL )
 392   7                                  {
 393   8                                  case 0x82:
 394   8                                      UEP2_CTRL = UEP2_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 395   8                                      break;
 396   8                                  case 0x81:
 397   8                                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_T_TOG | MASK_UEP_T_RES ) | UEP_T_RES_NAK;
 398   8                                      break;
 399   8                                  case 0x01:
 400   8                                      UEP1_CTRL = UEP1_CTRL & ~ ( bUEP_R_TOG | MASK_UEP_R_RES ) | UEP_R_RES_ACK;
 401   8                                      break;
 402   8                                  default:
 403   8                                      len = 0xFF;                                            // ²»Ö§³ÖµÄ¶Ëµã
 404   8                                      break;
 405   8                                  }
 406   7                              }
 407   6                              else
 408   6                              {
 409   7                                  len = 0xFF;                                                // ²»ÊÇ¶Ëµã²»Ö§³Ö
 410   7                              }
 411   6                              break;
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 8   

 412   6                          case USB_SET_FEATURE:                                              /* Set Feature */
 413   6                              if( ( UsbSetupBuf->bRequestType & 0x1F ) == 0x00 )             /* ÉèÖÃÉè±¸ */
 414   6                              {
 415   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x01
             - )
 416   7                                  {
 417   8                                      if( CfgDesc[ 7 ] & 0x20 )
 418   8                                      {
 419   9                                          /* ÉèÖÃ»½ÐÑÊ¹ÄÜ±êÖ¾ */
 420   9                                      }
 421   8                                      else
 422   8                                      {
 423   9                                          len = 0xFF;                                        /* ²Ù×÷Ê§°Ü */
 424   9                                      }
 425   8                                  }
 426   7                                  else
 427   7                                  {
 428   8                                      len = 0xFF;                                            /* ²Ù×÷Ê§°Ü */
 429   8                                  }
 430   7                              }
 431   6                              else if( ( UsbSetupBuf->bRequestType & 0x1F ) == 0x02 )        /* ÉèÖÃ¶Ëµã */
 432   6                              {
 433   7                                  if( ( ( ( UINT16 )UsbSetupBuf->wValueH << 8 ) | UsbSetupBuf->wValueL ) == 0x00
             - )
 434   7                                  {
 435   8                                      switch( ( ( UINT16 )UsbSetupBuf->wIndexH << 8 ) | UsbSetupBuf->wIndexL )
 436   8                                      {
 437   9                                      case 0x82:
 438   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã2 I
             -N STALL */
 439   9                                          break;
 440   9                                      case 0x02:
 441   9                                          UEP2_CTRL = UEP2_CTRL & (~bUEP_R_TOG) | UEP_R_RES_STALL;/* ÉèÖÃ¶Ëµã2 O
             -UT Stall */
 442   9                                          break;
 443   9                                      case 0x81:
 444   9                                          UEP1_CTRL = UEP1_CTRL & (~bUEP_T_TOG) | UEP_T_RES_STALL;/* ÉèÖÃ¶Ëµã1 I
             -N STALL */
 445   9                                          break;
 446   9                                      default:
 447   9                                          len = 0xFF;                               //²Ù×÷Ê§°Ü
 448   9                                          break;
 449   9                                      }
 450   8                                  }
 451   7                                  else
 452   7                                  {
 453   8                                      len = 0xFF;                                   //²Ù×÷Ê§°Ü
 454   8                                  }
 455   7                              }
 456   6                              else
 457   6                              {
 458   7                                  len = 0xFF;                                      //²Ù×÷Ê§°Ü
 459   7                              }
 460   6                              break;
 461   6                          case USB_GET_STATUS:
 462   6                              Ep0Buffer[0] = 0x00;
 463   6                              Ep0Buffer[1] = 0x00;
 464   6                              if ( SetupLen >= 2 )
 465   6                              {
 466   7                                  len = 2;
 467   7                              }
 468   6                              else
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 9   

 469   6                              {
 470   7                                  len = SetupLen;
 471   7                              }
 472   6                              break;
 473   6                          default:
 474   6                              len = 0xff;                                           //²Ù×÷Ê§°Ü
 475   6                              break;
 476   6                          }
 477   5                      }
 478   4                  }
 479   3                  else
 480   3                  {
 481   4                      len = 0xff;                                                   //°ü³¤¶È´íÎó
 482   4                  }
 483   3                  if(len == 0xff)
 484   3                  {
 485   4                      SetupReq = 0xFF;
 486   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_STALL | UEP_T_RES_STALL;//STALL
 487   4                  }
 488   3                  else if(len <= 8)                                                //ÉÏ´«Êý¾Ý»òÕß×´Ì¬½×¶Î·µ»Ø0³¤
             -¶È°ü
 489   3                  {
 490   4                      UEP0_T_LEN = len;
 491   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1£¬·
             -µ»ØÓ¦´ðACK
 492   4                  }
 493   3                  else
 494   3                  {
 495   4                      UEP0_T_LEN = 0;  //ËäÈ»ÉÐÎ´µ½×´Ì¬½×¶Î£¬µ«ÊÇÌáÇ°Ô¤ÖÃÉÏ´«0³¤¶ÈÊý¾Ý°üÒÔ·ÀÖ÷»úÌáÇ°½øÈë×´Ì¬½×¶Î
 496   4                      UEP0_CTRL = bUEP_R_TOG | bUEP_T_TOG | UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA1,·µ
             -»ØÓ¦´ðACK
 497   4                  }
 498   3                  break;
 499   3              case UIS_TOKEN_IN | 0:                                               //endpoint0 IN
 500   3                  switch(SetupReq)
 501   3                  {
 502   4                  case USB_GET_DESCRIPTOR:
 503   4                      len = SetupLen >= 8 ? 8 : SetupLen;                          //±¾´Î´«Êä³¤¶È
 504   4                      memcpy( Ep0Buffer, pDescr, len );                            //¼ÓÔØÉÏ´«Êý¾Ý
 505   4                      SetupLen -= len;
 506   4                      pDescr += len;
 507   4                      UEP0_T_LEN = len;
 508   4                      UEP0_CTRL ^= bUEP_T_TOG;                                     //Í¬²½±êÖ¾Î»·­×ª
 509   4                      break;
 510   4                  case USB_SET_ADDRESS:
 511   4                      USB_DEV_AD = USB_DEV_AD & bUDA_GP_BIT | SetupLen;
 512   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 513   4                      break;
 514   4                  default:
 515   4                      UEP0_T_LEN = 0;                                              //×´Ì¬½×¶ÎÍê³ÉÖÐ¶Ï»òÕßÊÇÇ¿ÖÆÉ
             -Ï´«0³¤¶ÈÊý¾Ý°ü½áÊø¿ØÖÆ´«Êä
 516   4                      UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 517   4                      break;
 518   4                  }
 519   3                  break;
 520   3              case UIS_TOKEN_OUT | 0:  // endpoint0 OUT
 521   3                  len = USB_RX_LEN;
 522   3                  if((SetupReq == 0x09)&& (len == 1))
 523   3                  {
 524   4                    LED_VALID = Ep0Buffer[0];
 525   4                                      /*
 526   4                                      // NUM_CLOCK ¼üÅÐ¶Ï
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 10  

 527   4                                      if(LED_VALID)   // Î´±»°´ÏÂ
 528   4                                              mTimer1RunCTL(1);
 529   4                                      else    // °´ÏÂ
 530   4                                              mTimer1RunCTL(0);
 531   4                                      */
 532   4                                      if(LED_VALID)
 533   4                                      {
 534   5                                              WS2812Data(0);
 535   5                                              WS2812Data(0);
 536   5                                              WS2812Data(0);
 537   5                                      }
 538   4                                      else
 539   4                                      {
 540   5                                              WS2812Data(255);
 541   5                                              WS2812Data(0);
 542   5                                              WS2812Data(0);
 543   5                                      }
 544   4                  }
 545   3                  else if((SetupReq == 0x09) && (len == 8)){//SetReport                                                
 546   4                  }                                                   
 547   3                  UEP0_T_LEN = 0;  //ËäÈ»ÉÐÎ´µ½×´Ì¬½×¶Î£¬µ«ÊÇÌáÇ°Ô¤ÖÃÉÏ´«0³¤¶ÈÊý¾Ý°üÒÔ·ÀÖ÷»úÌáÇ°½øÈë×´Ì¬½×¶Î
 548   3                  UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_ACK;//Ä¬ÈÏÊý¾Ý°üÊÇDATA0,·µ»ØÓ¦´ðACK
 549   3                  break;
 550   3              default:
 551   3                  break;
 552   3              }
 553   2              UIF_TRANSFER = 0;                                                 //Ð´0Çå¿ÕÖÐ¶Ï
 554   2          }
 555   1          if(UIF_BUS_RST)                                                       //Éè±¸Ä£Ê½USB×ÜÏß¸´Î»ÖÐ¶Ï
 556   1          {
 557   2              UEP0_CTRL = UEP_R_RES_ACK | UEP_T_RES_NAK;
 558   2              UEP1_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK;
 559   2              UEP2_CTRL = bUEP_AUTO_TOG | UEP_R_RES_ACK | UEP_T_RES_NAK;
 560   2              USB_DEV_AD = 0x00;
 561   2              UIF_SUSPEND = 0;
 562   2              UIF_TRANSFER = 0;
 563   2              UIF_BUS_RST = 0;                                                 //ÇåÖÐ¶Ï±êÖ¾
 564   2          }
 565   1          if (UIF_SUSPEND)                                                     //USB×ÜÏß¹ÒÆð/»½ÐÑÍê³É
 566   1          {
 567   2              UIF_SUSPEND = 0;
 568   2          }
 569   1          else {                                                               //ÒâÍâµÄÖÐ¶Ï,²»¿ÉÄÜ·¢ÉúµÄÇé¿ö
 570   2              USB_INT_FG = 0xFF;                                               //ÇåÖÐ¶Ï±êÖ¾
 571   2          }
 572   1      }
 573          /**¼üÅÌHIDÖµÉÏ´«º¯Êý**/
 574          void HIDValueHandle1()
 575          {
 576   1          //TR0 = 0; //·¢ËÍÇ°¹Ø¶¨Ê±Æ÷ÖÐ¶Ï
 577   1              FLAG = 0; //Çå¿ÕUSBÖÐ¶Ï´«ÊäÍê³É±êÖ¾£¬×¼±¸·¢ËÍ°´¼ü°´ÏÂÊý¾Ý
 578   1              Enp1IntIn(); //USBÉè±¸Ä£Ê½¶Ëµã1µÄÖÐ¶ÏÉÏ´«
 579   1              while(FLAG == 0); //µÈ´ýUSBÖÐ¶ÏÊý¾Ý´«ÊäÍê³É
 580   1              FLAG = 0; //Çå¿ÕUSBÖÐ¶Ï´«ÊäÍê³É±êÖ¾£¬×¼±¸·¢ËÍ°´¼üÌ§ÆðÊý¾Ý       
 581   1              memset(&HIDKey[0],0,8); //°ÑHIDkeyÖÃ0£¬·¢ËÍ0±íÊ¾°´¼üÌ§Æð
 582   1              Enp1IntIn(); //USBÉè±¸Ä£Ê½¶Ëµã1µÄÖÐ¶ÏÉÏ´«               
 583   1              while(FLAG == 0); //µÈ´ýUSBÖÐ¶ÏÊý¾Ý´«ÊäÍê³É
 584   1              //TR0 = 1; //·¢ËÍÍê´ò¿ª¶¨Ê±Æ÷ÖÐ¶Ï               
 585   1      }
 586          /**¶àÃ½Ìå°´¼üHIDÖµÉÏ´«º¯Êý**/
 587          void HIDValueHandle2()
 588          {
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 11  

 589   1          //TR0 = 0; //·¢ËÍÇ°¹Ø¶¨Ê±Æ÷ÖÐ¶Ï
 590   1              FLAG = 0; //Çå¿ÕUSBÖÐ¶Ï´«ÊäÍê³É±êÖ¾£¬×¼±¸·¢ËÍ°´¼ü°´ÏÂÊý¾Ý
 591   1              Enp2IntIn(); //USBÉè±¸Ä£Ê½¶Ëµã2µÄÖÐ¶ÏÉÏ´«
 592   1              while(FLAG == 0); //µÈ´ýUSBÖÐ¶ÏÊý¾Ý´«ÊäÍê³É
 593   1              FLAG = 0; //Çå¿ÕUSBÖÐ¶Ï´«ÊäÍê³É±êÖ¾£¬×¼±¸·¢ËÍ°´¼üÌ§ÆðÊý¾Ý       
 594   1              memset(&HIDKeyMUL[0],0,4); //°ÑHIDKeyMULÖÃ0£¬·¢ËÍ0±íÊ¾°´¼üÌ§Æð
 595   1              Enp2IntIn(); //USBÉè±¸Ä£Ê½¶Ëµã2µÄÖÐ¶ÏÉÏ´«               
 596   1              while(FLAG == 0); //µÈ´ýUSBÖÐ¶ÏÊý¾Ý´«Êä
 597   1              //TR0 = 1; //·¢ËÍÍê´ò¿ª¶¨Ê±Æ÷ÖÐ¶Ï               
 598   1      }
 599          /**°´¼üÐÐÎªº¯Êý**/
 600          /*ÕÒµ½°´¼üµÄHIDÖµ×ÔÓÉ·¢»Ó²¿·Ö*/
 601          /*ÆÕÍ¨°´¼ü
 602            ÀýÈçctrl + c :
 603            HIDKey[0] = 0x01;
 604            HIDKey[2] = 0x06;
 605            if(Ready) //Ã¶¾Ù³É¹¦
 606                  {
 607                      HIDValueHandle1();
 608                  }
 609          */
 610          
 611          // ÓÃÓÚÉÏ´«¹¦ÄÜ
 612          void Ready_function(void)
 613          {
 614   1              if(Ready) //Ã¶¾Ù³É¹¦
 615   1              {
 616   2                      HIDValueHandle1(); //ÆÕÍ¨°´¼üHIDÖµÉÏ´«
 617   2              }
 618   1      }
 619          
 620          /*********************************************************************************************************
             -****************************************/
 621          /*
 622          *       ÐÞ¸ÄÊ±¼ä£º2022.8.28
 623          *       ÐÞ¸ÄÈË£ºÁõ¼ÑºÀ
 624          *       ÐÞ¸ÄÄÚÈÝ£º1.Ôö¼ÓÔÚNUM_CLOCKÏÂË«»÷ "5" ¼üÇÐ»»µÆ¹âÐ§¹û
 625          *                         2.Ôö¼Ó¶¨Ê±2ÓÃÓÚ¼ì²âµÚÒ»´Î°´ÏÂÓëµÚ¶þ´Î°´ÏÂµÄÊ±¼ä¼ä¸ô
 626          */
 627          
 628          pdata UINT8 Time_Flag = 0; // ¼ÆÊ± ¿ªÊ¼/¹Ø±Õ ±êÖ¾Î»
 629          UINT8 LED_AttitudeFlag = 0;     // µÆÐ§ÇÐ»»±êÖ¾Î»
 630          
 631          unsigned long pdata Double_TimeThr = 0; // ¼ÆÊ±Ê±¼ä£¨²ÉÓÃ1msÖÐ¶ÏµÄ·½Ê½£©
 632          
 633          pdata UINT8 Key_Flag = 0;       // µÚÒ»´Î°´ÏÂ±êÖ¾Î»
 634          pdata UINT8 Key_DoubleFlag = 0; // µÚ¶þ´Î°´ÏÂ±êÖ¾Î»
 635          
 636          pdata UINT8 Add_Flag = 0;       // ÓÃÓÚµÆÐ§ÇÐ»»µÄÏÞ¶¨±êÖ¾Î»£¬Ê¹µÃ LED_AttitudeFlag Ö»¼ÓÒ»´Î
 637          
 638          // ¹Ø±ÕµÆ¹âº¯Êý
 639          /*
 640          *       ¶Ô17¸ö°´¼ü¸³ 0 Öµ£¬Í¬Ê±¶ÔµÚÒ»¸ö°´¼ü¸³Öµ£¬Ê¹µÃÖ»ÁÁµÚÒ»¸ö°´¼ü
 641          *       [ËµÃ÷]£ºÊ¹ÓÃ´Îº¯ÊýÊ± NUM_CLOCK ±ØÈ»°´ÏÂ
 642          */
 643          void LED_Close()
 644          {
 645   1              int j;
 646   1              for(j = 0; j < 17; j++)
 647   1              {
 648   2                      if(j == 0)
 649   2                      {
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 12  

 650   3                              WS2812Data(255);
 651   3                              WS2812Data(0);
 652   3                              WS2812Data(0);
 653   3                      }
 654   2                      else
 655   2                      {
 656   3                              WS2812Data(0);
 657   3                              WS2812Data(0);
 658   3                              WS2812Data(0);
 659   3                      }
 660   2              }
 661   1      }
 662          
 663          // °´¼üÐÐÎªµ÷ÓÃº¯Êý
 664          /*
 665          *       Í¨¹ý»ñÈ¡ÏàÓ¦¼üÖµ£¬²ÉÓÃ switch ¶ÔÃ¿Ò»¸ö¼üÖµ£¬½øÐÐ¶ÔÓ¦µÄº¯Êýµ÷ÓÃ
 666          *       [ËµÃ÷]£ºswitch ±È if Ð§ÂÊ¸ü¸ß
 667          *                       ¸Ã²¿·Ö¶Ô "5" ËùÔÚµÄ¼üÖµ½øÐÐ´¦Àí£¬ÓÐÐ§·ÀÖ¹ÆäËû°´¼ü³åÍ»ÎÊÌâ
 668          */
 669          void KeyAction(unsigned char keyCode)
 670          {
 671   1              switch(keyCode)
 672   1              {
 673   2                      case 0xE7:
 674   2                      {
 675   3                              HIDKey[2] = 0x53; 
 676   3                              Ready_function();
 677   3                      }       break;   // NUM CLOCK
 678   2                      
 679   2                      case 0xEB: HIDKey[2] = 0x54; Ready_function();  break;  // /
 680   2                      case 0xED: HIDKey[2] = 0x55; Ready_function();  break;  // *
 681   2                      case 0xEE: HIDKey[2] = 0x56; Ready_function();  break;  // -
 682   2                      
 683   2                      case 0xD7: HIDKey[2] = 0x5F; Ready_function();  break;  // 7
 684   2                      case 0xDB: HIDKey[2] = 0x60; Ready_function();  break;  // 8
 685   2                      case 0xDD: HIDKey[2] = 0x61; Ready_function();  break;  // 9
 686   2                      case 0xDE: HIDKey[2] = 0x57; Ready_function();  break;  // +
 687   2                      
 688   2                      case 0xB7: HIDKey[2] = 0x5C; Ready_function();  break;  // 4
 689   2                      
 690   2                      case 0xBB:
 691   2                      {                       
 692   3                              HIDKey[2] = 0x5D; 
 693   3                              Ready_function();
 694   3                              if(LED_VALID == 0)                                                                              // µ± NUM_CLOCK °´ÏÂÊ±
 695   3                              {
 696   4                                      if(Key_Flag == 0)                                                                       // Èç¹ûÊÇµÚÒ»´Î°´ÏÂ
 697   4                                      {
 698   5                                              Key_Flag = 1;   // ½«µÚÒ»´Î°´ÏÂµÄ±êÖ¾¸ü¸Ä£¬ÓÃÓÚºóÃæËÉÊÖ¼ì²â²¿·ÖµÄº¯ÊýÊ¹ÓÃ
 699   5                                              Time_Flag = 1;  // ¶¨Ê±Æ÷¼ÆÊ±¿ªÆô
 700   5                                              mTimer2RunCTL(1);       // ¶¨Ê±Æ÷2¿ªÆô
 701   5                                              Add_Flag = 1;   // ÀÛ¼Ó±êÖ¾¿ªÆô
 702   5                                      }
 703   4                              }
 704   3                      }       break;   // 5
 705   2                      
 706   2                      case 0xBD: HIDKey[2] = 0x5E; Ready_function();  break;  // 6
 707   2                      case 0xBE: HIDKey[2] = 0x58; Ready_function();  break;  // enter
 708   2                      
 709   2                      case 0x77: HIDKey[2] = 0x59; Ready_function();  break;  // 1
 710   2                      case 0x7B: HIDKey[2] = 0x5A; Ready_function();  break;  // 2
 711   2                      case 0x7D: HIDKey[2] = 0x5B; Ready_function();  break;  // 3
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 13  

 712   2                      case 0x7E: HIDKey[2] = 0x63; Ready_function();  break;  // .
 713   2                      
 714   2                      case 0x80: HIDKey[2] = 0x62; Ready_function();  break;  // 0
 715   2                      default: break;
 716   2              } 
 717   1      }
 718          
 719          /*
 720          °´¼ü¶¯×÷º¯Êý8
 721          void KeyAction(unsigned char keyCode)
 722          {   
 723                  if(keyCode == 0xE7)//°´¼ü1
 724                  {
 725                      HIDKey[2] = 0x05;  //´ò¿ªÃ½Ìå²¥·ÅÆ÷
 726                          if(Ready) //Ã¶¾Ù³É¹¦
 727                  {
 728                      HIDValueHandle1(); //¶àÃ½Ìå°´¼üHIDÖµÉÏ´«
 729                  }
 730                  }
 731                  if(keyCode == 0x32)//°´¼ü
 732                  {
 733                          HIDKey[2] = 0x5C;  //ÏÂÒ»Çú
 734                          if(Ready) //Ã¶¾Ù³É¹¦
 735                  {
 736                      HIDValueHandle1(); //¶àÃ½Ìå°´¼üHIDÖµÉÏ´«
 737                  }
 738                  }
 739                  if(keyCode == 0x33)     //°´¼ü3 
 740                  {
 741                          HIDKey[2] = 0x06;  //ÉÏÒ»Çú
 742                          if(Ready) //Ã¶¾Ù³É¹¦
 743                  {
 744                      HIDValueHandle1(); //ÆÕÍ¨°´¼üHIDÖµÉÏ´«
 745                  }
 746                  }
 747                  if(keyCode == 0x34)     //°´¼ü4 
 748                  {
 749                          HIDKey[2] = 0x07; //²¥·Å/ÔÝÍ£
 750          
 751                          if(Ready) //Ã¶¾Ù³É¹¦
 752                  {
 753                      HIDValueHandle1(); //¶àÃ½Ìå°´¼üHIDÖµÉÏ´«
 754                  }
 755                  }
 756          //      if(keyCode == 0x35)     //°´¼ü5 
 757          //      {
 758          //              HIDKeyMUL[0] = 0x02; //ÒôÁ¿+
 759          
 760          //              if(Ready) //Ã¶¾Ù³É¹¦
 761          //        {
 762          //            HIDValueHandle2(); //¶àÃ½Ìå°´¼üHIDÖµÉÏ´«
 763          //        }
 764          //      }
 765          //      if(keyCode == 0x36)     //°´¼ü6 
 766          //      {
 767          //              HIDKeyMUL[0] = 0x01; //ÒôÁ¿-
 768          
 769          //              if(Ready) //Ã¶¾Ù³É¹¦
 770          //        {
 771          //            HIDValueHandle2(); //¶àÃ½Ìå°´¼üHIDÖµÉÏ´«
 772          //        }
 773          //      }
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 14  

 774          }
 775          */
 776          
 777          // °´¼üÇý¶¯
 778          // ÓÃÍ¾£º·ÅÔÚmainº¯ÊýÖÐ¶ÁÈ¡°´¼ü×´Ì¬£¬½øÐÐÏàÓ¦µÄ´¦Àí
 779          void KeyDrive()
 780          {
 781   1              if(KeyState != BackState)                                                                               // Èç¹ûµ±Ç°°´¼ü×´Ì¬ÓëÉÏÒ»´ÎµÄ°´¼ü×´Ì¬²»ÏàµÈ£¬¼´°´¼ü±»°´ÏÂ
 782   1              {
 783   2                      if(BackState != 0)                                                                                      // Èç¹ûÉÏÒ»´Î°´¼ü×´Ì¬²»Îª0£¬¼´ÔÙ´ÎÅÐ¶ÏÊÇ·ñ±»°´ÏÂ
 784   2                      {
 785   3                              KeyAction(key); // µ÷ÓÃ°´¼ü¹¦ÄÜº¯Êý
 786   3                      }
 787   2                      BackState = KeyState;                                                                           // °´¼ü×´Ì¬Ë¢ÐÂ
 788   2              }
 789   1              if(KeyDownTime > 0)                                                                                             // ´ËÖÖÇé¿öÊÇ³¤°´£¬Èç¹û°´ÏÂµÄÊ±¼ä´óÓÚ0
 790   1              {
 791   2                      if(KeyDownTime >=  TimeThr)                                                                     // Èç¹û°´ÏÂµÄÊ±¼ä´ïµ½Éè¶¨Öµ
 792   2                      {
 793   3                              KeyAction(key); // µ÷ÓÃ°´¼ü¹¦ÄÜº¯Êý
 794   3                              TimeThr += 100; // Ôö´óÉè¶¨Öµ£¬Ê¹µÃµ÷ÓÃ¹¦ÄÜº¯ÊýÃ»ÄÇÃ´¿ì
 795   3                      }
 796   2              }
 797   1              else                                                                                                                    // ÎÞ°´¼ü°´ÏÂ
 798   1              {
 799   2                      TimeThr = 1000; // ÖØÖÃÉè¶¨Ê±¼ä
 800   2                      if(Key_Flag == 1)                                                                                       // °´¼üµÚÒ»´Î°´ÏÂ
 801   2                      {
 802   3                              Key_Flag = 0;   // Çå¿Õ±êÖ¾£¬µÈ´ýµÚ¶þ´Î°´ÏÂ
 803   3                              if(Key_DoubleFlag == 0)                                                                 // Èç¹ûµÚ¶þ´ÎÎ´±»°´ÏÂ
 804   3                              {
 805   4                                      Key_DoubleFlag = 1;     // ¼¤»îµÚ¶þ´Î°´ÏÂµÄ±êÖ¾
 806   4                                      Double_TimeThr = 0;     // ÖØÖÃËÉÊÖ¼ÆÊ±
 807   4                              }
 808   3                              else if(Key_DoubleFlag == 1)                                                    // Èç¹ûµÚ¶þ´Î°´ÏÂ
 809   3                              {
 810   4                                      if(Double_TimeThr < 500 && Add_Flag == 1)                       // Èç¹ûµÚÒ»´ÎÓëµÚ¶þ´Î°´ÏÂµÄÊ±¼ä¼ä¸ôÐ¡ÓÚ 0.5s ²¢ÇÒÀÛ¼Ó±ê¼ÇÎ
             -ª1
 811   4                                      {
 812   5                                              Key_DoubleFlag = 0;     // µÚ¶þ´Î°´ÏÂµÄ±êÖ¾Çå¿Õ
 813   5                                              Add_Flag = 0;   // ÀÛ¼Ó±êÖ¾Çå¿Õ
 814   5                                              if(LED_AttitudeFlag >= 4)                                               // Èç¹ûµÆÐ§ÀÛ¼Ó±êÖ¾³¬¹ý4
 815   5                                                      LED_AttitudeFlag = 0;   // ÖØÖÃÎª0
 816   5                                              switch(LED_AttitudeFlag)                                                // ÓÃÓÚÇÐ»»µÆÐ§£¨Ä¬ÈÏÎÞµÆ¹â£©
 817   5                                              {
 818   6                                                      case 0:                                                                         // µÚÒ»ÖÖµÈÐ§
 819   6                                                      {
 820   7                                                              i = 0;  // ÖØÖÃ DS2812B ÀÛ¼Ó¼ÆÊýÆ÷
 821   7                                                              LED_AttitudeFlag++;     // µÈÐ§ÀÛ¼Ó±êÖ¾¼ÓÒ»
 822   7                                                              WS2812B_DisplayType = 0; // µÈÐ§±êÖ¾ÖÃÎª0
 823   7                                                              mTimer1RunCTL(1); // ¿ªÆô¶¨Ê±Æ÷1£¬¿ªÊ¼ÏÔÊ¾µÆ¹â
 824   7                                                      }       break;
 825   6                                                      case 1:                                                                         // µÚ¶þÖÖµÈÐ§
 826   6                                                      {
 827   7                                                              mTimer1RunCTL(0); // ¹Ø±Õ¶¨Ê±Æ÷1£¨·ÀÖ¹¶¨Ê±Æ÷ÄÚ²¿¼ÆÊ±²»×¼µÄÎÊÌâ£©
 828   7                                                              i = 0; // ÖØÖÃ DS2812B ÀÛ¼Ó¼ÆÊýÆ÷
 829   7                                                              count_num = 0; // ÖØÖÃ¶¨Ê±Æ÷ÄÚ²¿¼ÆÊýÀÛ¼ÓÆ÷
 830   7                                                              LED_AttitudeFlag++; // µÈÐ§ÀÛ¼Ó±êÖ¾¼ÓÒ»
 831   7                                                              WS2812B_DisplayType = 1; // µÈÐ§±êÖ¾ÖÃÎª1
 832   7                                                              mTimer1RunCTL(1); // ¿ªÆô¶¨Ê±Æ÷1£¬¿ªÊ¼ÏÔÊ¾µÆ¹â
 833   7                                                      }       break;
 834   6                                                      case 2:                                                                         // µÚÈýÖÖµÈÐ§
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 15  

 835   6                                                      {
 836   7                                                              mTimer1RunCTL(0); // ¹Ø±Õ¶¨Ê±Æ÷1£¨·ÀÖ¹¶¨Ê±Æ÷ÄÚ²¿¼ÆÊ±²»×¼µÄÎÊÌâ£©
 837   7                                                              i = 0; // ÖØÖÃ DS2812B ÀÛ¼Ó¼ÆÊýÆ÷
 838   7                                                              count_num = 0; // ÖØÖÃ¶¨Ê±Æ÷ÄÚ²¿¼ÆÊýÀÛ¼ÓÆ÷
 839   7                                                              LED_AttitudeFlag++; // µÈÐ§ÀÛ¼Ó±êÖ¾¼ÓÒ»
 840   7                                                              WS2812B_DisplayType = 2; // µÈÐ§±êÖ¾ÖÃÎª1
 841   7                                                              mTimer1RunCTL(1); // ¿ªÆô¶¨Ê±Æ÷1£¬¿ªÊ¼ÏÔÊ¾µÆ¹â
 842   7                                                      }       break;
 843   6                                                      case 3:                                                                         // ¹Ø±ÕµÆ¹â
 844   6                                                      {
 845   7                                                              mTimer1RunCTL(0); // ¹Ø±Õ¶¨Ê±Æ÷1£¨·ÀÖ¹¶¨Ê±Æ÷ÄÚ²¿¼ÆÊ±²»×¼µÄÎÊÌâ£©
 846   7                                                              count_num = 0; // ÖØÖÃ¶¨Ê±Æ÷ÄÚ²¿¼ÆÊýÀÛ¼ÓÆ÷
 847   7                                                              LED_Close(); // µ÷ÓÃ¹Ø±ÕµÆ¹âº¯Êý TP 642
 848   7                                                              LED_AttitudeFlag++; // µÈÐ§ÀÛ¼Ó±êÖ¾¼ÓÒ»
 849   7                                                      }       break;
 850   6                                                      default: break;
 851   6                                              }
 852   5                                      }
 853   4                              }
 854   3                      }
 855   2                      else if(Key_DoubleFlag == 1)                                                            // Èç¹ûµÚÒ»´ÎÒÑ¾­°´ÏÂ
 856   2                      {
 857   3                              if(Double_TimeThr >= 500)                                                               // µÚ¶þ´ÎÎ´ÔÚ 0.5s ÄÚ°´ÏÂ
 858   3                              {
 859   4                                      Key_DoubleFlag = 0;     // µÚ¶þ´Î°´ÏÂµÄ±êÖ¾Î»Çå¿Õ
 860   4                                      
 861   4                                      /* ´Ë´¦Âß¼­ÓÐ´ýÍêÉÆ */
 862   4      //                              LED_AttitudeFlag = 0; // µÈÐ§ÀÛ¼Ó Çå¿Õ
 863   4                                      
 864   4                                      Time_Flag = 0; // ¼ÆÊ±±êÖ¾Çå¿Õ
 865   4                                      Double_TimeThr = 0;     // ¼ÆÊ±Ê±¼äÇå¿Õ
 866   4                                      mTimer2RunCTL(0);       // ¹Ø±Õ¶¨Ê±Æ÷2
 867   4                              }
 868   3                      }
 869   2              }
 870   1      }
 871          ///**°´¼üÇý¶¯**/
 872          //void KeyDrive()
 873          //{
 874          //      unsigned char j;
 875          
 876          //      for(j=0;j<4;j++)
 877          //      {
 878          //              if(KeyState[j] != BackState[j])
 879          //              {
 880          //              if(BackState[j] != 0)
 881          //                      {
 882          //                              KeyAction(key_code_map[j]);
 883          //                      }
 884          //                      BackState[j] = KeyState[j]; 
 885          //              }
 886          //              if(KeyDownTime[j] > 0)
 887          //              {
 888          //                      if(KeyDownTime[j] >= TimeThr[j])
 889          //                      {
 890          //                              KeyAction(key_code_map[j]);
 891          //                              TimeThr[j] += 100;
 892          //                      } 
 893          //              }
 894          //              else
 895          //              {
 896          //                      TimeThr[j] = 1000;
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 16  

 897          //              }               
 898          //      }
 899          //}
 900          
 901          /**T0ÅäÖÃº¯Êý**/
 902          void ConfigT0(UINT8 ms)
 903          {
 904   1          unsigned long tmp = 0;
 905   1      
 906   1              tmp = 24000000/12;
 907   1              tmp = (tmp * ms)/1000;
 908   1              tmp = 65536 - tmp;
 909   1              tmp = tmp + 1;
 910   1          T0RH = (UINT8)(tmp >> 8);
 911   1              T0RL = (UINT8)tmp;
 912   1      
 913   1              TMOD = ( TMOD & ~( bT0_GATE | bT0_CT | bT0_M1 ) ) | bT0_M0;//* Ä£Ê½1£¬16 Î»¶¨Ê±/¼ÆÊýÆ÷
 914   1      //      TMOD = 0x11;
 915   1              TH0 = T0RH;
 916   1              TL0 = T0RL;
 917   1              TF0 = 0;
 918   1              ET0 = 1;
 919   1              TR0 = 1;
 920   1      }
 921          
 922          UINT8 T2RH = 0; //T2¸ß8Î»ÖØÔØÖµ
 923          UINT8 T2RL = 0; //T2µÍ8Î»ÖØÔØÖµ
 924          
 925          /**T2ÅäÖÃº¯Êý**/
 926          void ConfigT2(UINT8 ms)
 927          {
 928   1          unsigned long tmp = 0;
 929   1      
 930   1              tmp = 24000000/12;
 931   1              tmp = (tmp * ms)/1000;
 932   1              tmp = 65536 - tmp;
 933   1              tmp = tmp + 1;
 934   1          T2RH = (UINT8)(tmp >> 8);
 935   1              T2RL = (UINT8)tmp;
 936   1      
 937   1      //      T2MOD = ( T2MOD & ~( bT1_GATE | bT1_CT | bT1_M1 ) ) | bT1_M0;//* Ä£Ê½1£¬16 Î»¶¨Ê±/¼ÆÊýÆ÷
 938   1              T2MOD |= (bTMR_CLK | bT2_CLK);
 939   1              C_T2=0;
 940   1              RCLK = 0;
 941   1              TCLK = 0;
 942   1              CP_RL2 = 0;
 943   1              TH2 = T2RH;
 944   1              TL2 = T2RL;
 945   1              ET2 = 1;
 946   1      //      TR1 = 1;
 947   1      }
 948          
 949          //timer2ÖÐ¶Ï·þÎñ³ÌÐò
 950          void    mTimer2Interrupt( void ) interrupt INT_NO_TMR2 using 3
 951          {
 952   1              mTimer2RunCTL(0);
 953   1              if(TF2)
 954   1          {
 955   2              TF2 = 0;  // Çå¿Õ¶¨Ê±Æ÷2Òç³öÖÐ¶Ï          
 956   2              if(Time_Flag)                                                                                           // Èç¹û¼ÆÊ±¿ªÊ¼
 957   2                      {
 958   3                              Double_TimeThr++; // Ê±¼äÀÛ¼Ó
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 17  

 959   3                      }
 960   2                      else                                                                                                            // ¼ÆÊ±Î´¿ªÊ¼
 961   2                      {
 962   3                              Double_TimeThr = 0;     // Ê±¼äÖÃ¿Õ
 963   3                      }
 964   2          }
 965   1              mTimer2RunCTL(1);
 966   1      }
 967          
 968          
 969          /*****************Ö÷º¯Êý**********************/
 970          main()
 971          {
 972   1          CfgFsys(); //CH552Ê±ÖÓÑ¡Ôñ12MÅäÖÃ
 973   1          mDelaymS(5); //ÐÞ¸ÄÖ÷ÆµµÈ´ýÄÚ²¿¾§ÕñÎÈ¶¨,±Ø¼Ó        
 974   1              ConfigT0(10); //ÅäÖÃ10ms T0ÖÐ¶Ï
 975   1              ConfigT1(25); //ÅäÖÃ1000ms T1ÖÐ¶Ï
 976   1              ConfigT2(1);
 977   1              mTimer1RunCTL(0); //¶¨Ê±Æ÷1Ä¬ÈÏ¹Ø±Õ
 978   1              mTimer2RunCTL(0);
 979   1              USBDeviceInit(); //USBÉè±¸Ä£Ê½³õÊ¼»¯
 980   1          EA = 1; //ÔÊÐíµ¥Æ¬»úÖÐ¶Ï
 981   1          UEP1_T_LEN = 0; //Ô¤Ê¹ÓÃ·¢ËÍ³¤¶ÈÒ»¶¨ÒªÇå¿Õ
 982   1              UEP2_T_LEN = 0; //Çå¿Õ¶Ëµã2·¢ËÍ³¤¶È
 983   1          FLAG = 0; //Çå¿ÕUSBÖÐ¶Ï´«ÊäÍê³É±êÖ¾
 984   1          Ready = 0;
 985   1      //      LED_VALID = 1;   //¸øÒ»¸öÄ¬ÈÏÖµ
 986   1      
 987   1              while(1)
 988   1              {
 989   2                  KeyDrive(); //°´¼üÇý¶¯
 990   2                      
 991   2              }
 992   1      }
 993          
 994          // °´¼üÉ¨Ãè
 995          // ÐÐÁÐ·´É¨Ãè·¨
 996          void KeyScan()
 997          {
 998   1              UINT8 temp; 
 999   1              write_data(0xf0);       // ¸ß4Î»ÖÃ 1 
1000   1              
1001   1              if(read_data() != 0xf0 || LED17 != 1)                                                   // Èç¹ûÓÐ°´¼ü±»°´ÏÂ »òÕß °´¼ü17±»°´ÏÂ
1002   1              {
1003   2                      if(read_data() != 0xf0 || LED17 != 1)                                           // ÔÙ´ÎÈ·ÈÏ
1004   2                      {
1005   3                              KeyState = 0;   // °´¼ü×´Ì¬ÖÃ0
1006   3                              if(read_data() != 0xf0)                                                                 // Èç¹ûÊÇ¾ØÕó°´¼ü±»°´ÏÂ
1007   3                              {
1008   4                                      temp = read_data();     // ¶Á³ö¼üÖµ
1009   4                                      write_data(0x0F);       // ·´×ª µÍ4Î»ÖÃ 1
1010   4                                      key = temp | read_data();       // ¶Á³öÁ½Öµ½øÐÐ»òÔËËãµÃ³ö¼üÖµ
1011   4                              }
1012   3                              if(LED17 != 1)                                                                                  // Èç¹û°´¼ü17±»°´ÏÂ
1013   3                              {
1014   4                                      key = 0x80;                                                                                     // ¸ü¸Ä¼üÖµ¶ÁÊýÎª 0x80
1015   4                              }
1016   3                              KeyDownTime += 25;                                                                              // Ö»ÒªÓÐ°´¼ü°´ÏÂ£¬°´ÏÂÊ±¼ä¾Í¼Ó25
1017   3                      }
1018   2              }
1019   1              else                                                                                                                    // ÎÞ°´¼ü°´ÏÂ
1020   1              {
C51 COMPILER V9.60.0.0   MAIN                                                              08/28/2022 12:31:39 PAGE 18  

1021   2                      key = 0; // ¼üÖµ»º´æÇå¿Õ
1022   2                      KeyState = 1;   // °´¼ü×´Ì¬ÖÃ1
1023   2                      KeyDownTime = 0;        // °´ÏÂÊ±¼äÇå¿Õ
1024   2              }
1025   1      }
1026          /**T0ÖÐ¶Ïº¯Êý**/
1027          void InterruptTimer0() interrupt INT_NO_TMR0 using 2
1028          {
1029   1              TH0 = T0RH;
1030   1              TL0 = T0RL;
1031   1      
1032   1              KeyScan(); //°´¼üÉ¨Ãè
1033   1      }
1034          
1035          
1036          
1037          /*********************************************************************************************************
             -********/
1038          
1039          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2308    ----
   CONSTANT SIZE    =    250    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     16    ----
   DATA SIZE        =     40      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
